# Udacity Robotics Software Engineer Nonodegree
Here is my projects of Robotics Software Engineer Nanodegree. The applications involve in these projects are ROS(Kinetic), Gazebo, and the code is in C++
# Certificate of Completion
![1730245062514](https://github.com/user-attachments/assets/25c21c43-56f7-4e0a-96ed-44977f458457)

https://www.udacity.com/certificate/e/55e2ab34-1dcf-11ef-b317-6f3d5d70024d

# Core Projects
## Environment
* Ubuntu 18.04 LTS running in VitualBox
* ROS Kinetic

## Projects 1-2
I combine both projects here as Chase Ball Robot project. This project involves create a robotic environment in Gazebo, create a differential drive robot, and write C++ ROS nodes to make the robot chase a white ball.

![1730251423411](https://github.com/user-attachments/assets/363e782a-6e01-4f38-b075-05381ff774ee)


## Project 3-5
I combine those three projects as Home Service Robot project. 

![](https://github.com/Xueting-Deng/Robotics-Software-Engineer-Program-Projects/blob/main/Home%20Service%20Robot/home%20service%20gif.gif)

The aim of this project is to navigate a drivable robot to pick up an object at a certain point, and then drop the object off at another drop-off point. The robot is equipped with a RGB-D camera and a Hokuyo Lidar. This project first used slam_gmapping package to create a 2d occupancy grid map. This package uses a partical highly efficient filter-based SLAM. However, without tuning the parameter well, the map I created doesn't reach the best accuracy:
![1730254595893](https://github.com/user-attachments/assets/97c87c55-00d1-44b0-bc93-de9bcb3bbcf9)
![1730379737762](https://github.com/user-attachments/assets/b3efaf0d-bc4e-4f15-bddd-6998b7b0d6f2)

Therefore, for path planning part, this project uses the map generated by pgm_map_creator that can generate map directly from Gazebo. The path planning part achieved by using ROS Navigation stack. This stack created a path based on Dijktra's algorithm. I'm not so sure how does this algorithm generate the weighted graph (need to read more reference). The pick_objects.cpp defines a client to send the goal position to robot's move server, checks if the robot reaches the goal and displays messages according to the robot's state. The add_marker.cpp displays the object with detecting if the robot arrives at the goal position.


